---
title: Modeling gene regulation with BioSimulator.jl
options:
    fig_ext: .svg
---

```{julia; results = "hidden"}
# TODO: run the installation script once
```

```{julia}
using BioSimulator
```

## Example 1: Negative auto-regulation

This example introduces the interface and basic features of BioSimulator.jl.
We will work with a model of gene regulation in prokaryotes taken from the text:

> Wilkinson, D. J. (2006) *Stochastic Modelling for Systems Biology*.
> 1st ed., Chapman & Hall / CRC, Boca Raton, FL.

Here dimers of a protein coded by a gene repress their own transcription by binding a regulatory region lying between the gene and its promoter.
The flow of information can be summarized by $8$ biochemical reactions involving $5$ species:

$$
\begin{eqnarray*}
\mathrm{gene_{on}} + P_{2} &\iff& \mathrm{gene_{off}} & \text{binding/unbinding} \\
\mathrm{gene_{on}} &\longrightarrow& \mathrm{gene} + \mathrm{RNA} & \text{transcription} \\
\mathrm{RNA} &\longrightarrow& \mathrm{RNA} + P & \text{translation} \\
P + P &\longrightarrow& P_{2} & \text{dimerization/dissociaton} \\
\mathrm{RNA} &\longrightarrow& \emptyset & \text{mRNA degradation} \\
\mathrm{P} &\longrightarrow& \emptyset & \text{protein degradation}
\end{eqnarray*}
$$

This simplified description adequately captures the interesting features of regulatory networks.

### Model specification

The `Network` object is the workhorse for discrete spatial-free models in BioSimulator.
It collects coupled `Reaction` objects that describe interactions between `Species`.
The present example emphasizes biochemical reactions in gene networks, but the software applies to general population dynamics that can be described within a continuous-time Markov chain framework.

```{julia}
function negautoreg(;
    x = [1, 0, 0, 0, 0],
    k = [1.0, 10.0, 0.01, 10.0, 1.0, 1.0, 0.1, 0.01]
)
    # initialize model
    m = Network("negative auto-regulation")

    # species definitions
    m <= Species("gene_on", x[1])
    m <= Species("gene_off", x[2])
    m <= Species("RNA", x[3])
    m <= Species("P", x[4])
    m <= Species("P2", x[5])

    # reaction definitions
    m <= Reaction("binding", k[1], "gene_on + P2 --> gene_off")
    m <= Reaction("unbinding", k[2], "gene_off --> gene_on + P2")
    m <= Reaction("transcription", k[3], "gene_on --> gene_on + RNA")
    m <= Reaction("translation", k[4], "RNA --> RNA + P")
    m <= Reaction("dimerization", k[5], "P + P --> P2")
    m <= Reaction("dissociation", k[6], "P2 --> P + P")
    m <= Reaction("RNA degradation", k[7], "RNA --> 0")
    m <= Reaction("protein degradation", k[8], "P --> 0")

    return m
end
```

### Simulation

```{julia}
network = negautoreg(x = [10, 0, 0, 0, 0])
state, model = parse_model(network)
```

```{julia}
# simulation settings
tfinal = 500.0
algorithm = SortingDirect()
ntrials = 10^3
save_pts = 0:5:tfinal

# generate a single realization
trajectory = simulate(state, model, SortingDirect(), tfinal = tfinal)

# generate an ensemble
ensemble = [simulate(state, model, SortingDirect(), tfinal = tfinal, save_points = save_pts) for _ in 1:ntrials]
```

### Handling simulation data

#### Accessing results

#### Plotting `SamplePath` data

A `SamplePath` object is fully compatible with the Plots.jl ecosystem, meaning the command `plot(trajectory)` just works.
Load the Plots package and select the GR backend:

```{julia}
using Plots
gr(grid = false) # you can set default options for the plotting backend

plot(trajectory)
```

Unfortunately, this is not terribly useful yet.
The axes are not labeled and it is not clear what each trajectory represents.
Fortunately, we can fix these issues using the keyword arguments to the `plot` function.

```{julia}
# The piping operator |> can be used to chain function calls.
# This is equivalent to collect(keys(species_list(network))).
# The reshape command is needed because Plots treats each column as a series.
temp = species_list(network) |> keys |> collect
species_labels = reshape(temp, 1, length(temp))

plot(trajectory,
    xlabel = "time (A.U.)",
    ylabel = "counts",
    label = species_labels)
```

Next we need to fix crowding.
We have a couple of choices for presenting the trajectories.

##### Option 1: Split each species into separate subfigures

```{julia}
plot(trajectory,
    xlabel = "time (A.U.)",
    ylabel = "counts",
    title = species_labels,
    layout = grid(5, 1),
    size = (400,600),
    legend = false)
```

##### Options 2: Group species into panels

```{julia}
panelA = plot(trajectory,
    title = species_labels,
    vars = (1,2,3),
    layout = grid(3, 1),
    legend = false)

panelB = plot(trajectory,
    vars = (4,5), title = "protein", label = ["monomer" "dimer"], legend = :left)

plot(panelA, panelB,
    xlabel = "time (A.U.)",
    ylabel = "counts",
    layout = @layout [a{0.35w} a{0.65w}])
```

#### Plotting `Ensemble` data

##### Summary statistics

```{julia}
panelA = plot(ensemble,
    vars = (1,2),
    title = "gene",
    ylabel = "Pr(state)",
    label = ["ON" "OFF"])

panelB = plot(ensemble, summary = :mean,
    vars = 3,
    title = "mRNA",
    ylabel = "average count",
    legend = false)

panelC = plot(ensemble,
    vars = (4,5),
    title = "protein",
    ylabel = "average count",
    label = ["monomer" "dimer"])

plot(panelA, panelB, panelC,
    layout = grid(3, 1),
    size = (500, 600))
```

##### Distributions

```{julia}
plot(ensemble, summary = :histogram,
    vars = 3, timepoint = 250.0, legend = false, title = "mRNA @ t = 250")
```

```{julia}
animation = @animate for t in save_pts[2:end]
    figA = plot(ensemble, summary = :histogram, timepoint = t,
        vars = 3,
        title = "mRNA @ t = $(t)",
        xlims = (0, 2),
        ylims = (0, 1),
        normalize = :probability)

    figB = plot(ensemble, summary = :histogram, timepoint = t,
        vars = 4,
        title = "monomer",
        xlims = (0, 60),
        ylims = (0, 0.2),
        normalize = :probability)

    figC = plot(ensemble, summary = :histogram, timepoint = t,
        vars = 5,
        title = "dimer",
        xlims = (0, 1000),
        ylims = (0, 0.3),
        normalize = :probability)

    plot(figA, figB, figC, layout = grid(1, 3), legend = false, ylabel = "probability", xlabel = "count")
end

gif(animation, fps = 10)
```

##### Phase plots

```{julia}
plot(ensemble, summary = :phase,
    vars = (4, 5),
    xlabel = "monomer",
    ylabel = "dimer",
    colorbar = true,
    colorbar_title = "time")
```
